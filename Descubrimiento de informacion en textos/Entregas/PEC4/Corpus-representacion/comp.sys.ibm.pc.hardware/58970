Nntp-Posting-Host: eniac.seas.upenn.eduHello.  I hope somebody out here can help me.  I am currently workingon a project where I am trying to communicate from an IBM 386 withPhoenix BIOS, using C++, to a board that I made with an Intel 8085 CPUwith UART chip.  The board works fine with the TRANSMIT command andTerminal Emulation mode of Kermit, but there seems to be something wrongwith the initialization or protocol used when I try C++.  I need toaccess the unit I built using C, because I have a sizable chunk of Ccode that I will be using to perform calculations and operations thatwill be very difficult to code in assembly language for the 8085.I have included the assembly code that I am running and the C++ codethat I am trying to use.  If anyone can show me something that Iam doing blatantly incorrectly or that I am missing because of my lackof knowledge about RS-232 serial communications, please e-mail me.I wrote the assembly language to wait for a character to be received andthen to check it against the 0x20 character, if a 0x20 is received,the LEDs will indicate this.  Two C++ programs that I have written donothing, but set up COM port 2 and send the 0x20 character.  One usesthe bioscom() function in bios.h the other uses the software interruptint86() function in dos.h.  I have triple checked the baud rate ( 2400 )the parity ( none ) the stop bits ( 1 ) the character length ( 8 bits )and the interrupt calls for ( 0x14 ).  Currently, I am at a loss asto what may be wrong.  Any hardware gurus out there want to comment?Thanks alot,Hubert De Jesusdejesus@eniac.seas.upenn.eduINTEL ASMCOMMAND     EQU     3000H                ;Command Register on 8155PORTA       EQU     3001H                ;Port A on 8155TIMERLO     EQU     3004H                ;High 8 bits of 8155 TimerTIMERHI     EQU     3005H                ;Low 8 bits of 8155 TimerUARTDATA    EQU     E000H                ;UART Data RegisterUARTCMD     EQU     E001H                ;UART Command RegisterORG     4000H                ;SRAM locationMVI     A,08H		 ;Set Low Timer BitsSTA     TIMERLOMVI     A,40H		 ;Set High Timer BitsSTA     TIMERHIMVI     A,11111101B          ;Start Timer & Enable Port ASTA     COMMANDMVI     A,11H                ;Display 11 on 7-segment LEDsSTA     PORTAMVI     A,00H		 ;Clear UART CommandSTA     UARTCMDSTA     UARTCMDSTA     UARTCMDMVI     A,01000000B		 ;Internally reset UARTSTA     UARTCMDLDA     UARTDATA             ;Remove extraneous dataMVI     A,01001111B          ;Init UART for 8 data bits,STA     UARTCMD              ;  no parity, 1 stop bit, 64x asyncMVI     A,00100111B          ;Enable Transmit and ReceiveSTA     UARTCMDINIT:       LDA     UARTCMD		 ;Read Status RegisterANI     02H                  ;Is RxRDY?JZ      INIT                 ;No, loopLDA     UARTDATA             ;Read Data CharacterCPI     ' '                  ;Is Character = 0x20?JNZ     INIT                 ;No, loopMVI     A,22H                ;Character received,STA     PORTA                ;  Display 22 on 7-segment LEDsHLTENDC++ using BIOSCOM()#include <stdio.h>#include <stdlib.h>#include <bios.h>#define INIT          0#define SEND          1#define RECEIVE       2#define STATUS        3#define COM2          1voidmain(){char abyte;abyte = 0xa3;bioscom( INIT, abyte, COM2 );printf( "Initialized COMM PORT 2\n" );while( !( bioscom( STATUS, 0, COM2 ) & 0x4000 ) );abyte = ' ';bioscom( SEND, abyte, COM2 );printf( "Sent start character\n" );}C++ using INT86()#include <stdio.h>#include <stdlib.h>#include <dos.h>#include <bios.h>main(){union REGS registers;registers.h.ah = 0x00;registers.h.al = 0xa7;registers.x.dx = 0x01;int86( 0x14, &registers, &registers );printf( "COM2 Initialized\n" );registers.h.ah = 0x01;registers.h.al = 0x20;registers.x.dx = 0x01;int86( 0x14, &registers, &registers );printf( "Sent start character\n" );}